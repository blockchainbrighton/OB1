<!--HTML_Template.html-->

<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>OB1 #1 - Audional Art</title><style>body{background-color:#000000;display:flex;justify-content:center;align-items:center;height:100vh;margin:0}img {width: auto;height: auto;max-width: 60%;max-height: 80vh;object-fit: contain;aspect-ratio: 1 / 1;}
</style></head><body>
<img id="OB1_Image" src="data:image/jpeg;base64,/9j/4AAQSkZJRgABAQEAYABgAAD... shortened for brevity">
<audio id="audionalData" loop data-audionalSampleName="808 Kick Drum">
<source src="data:audio/wav;base64,UklGRk6GAQB... shortened for brevity">
Your browser does not support the audio element.
</audio>
<div id= "BPM">78 BPM</div> 
<style>
    #BPM {
        font-size: 24px; /* Adjust the font size as needed */
        font-weight: bold;
        color: rgb(255, 251, 0);
        position: absolute;
        top: 5%;
        left: 50%;
        transform: translate(-50%, -50%);
        opacity: 0; /* Initially set the opacity to 0 for fade in effect */
        transition: opacity 0.5s ease-in-out; /* Apply transition for smooth fade in/out */
    }

    #BPM.show {
        opacity: 1; /* Set opacity to 1 to make the element visible */
    }


</style>
<script>
    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
    const gainNode = audioContext.createGain().connect(audioContext.destination);
    gainNode.gain = 0.5; // Initialize gain to a reasonable level to control volume

    let state = {
        bpm: 78,
        isLooping: false,
        audioBuffer: null,
        nextNoteTime: audioContext.currentTime,
        scheduledNotes: [],
        scheduleMultiplier: 1,
    };

    document.addEventListener('DOMContentLoaded', () => {
        console.log("[DOMContentLoaded] Loading audio data...");
        fetchAndDecodeAudio("audionalData");
    });

    document.getElementById("OB1_Image").addEventListener("click", async () => {
        if (audioContext.state === 'suspended') {
            await audioContext.resume();
        }
        console.log(`[Click Event] Looping state: ${state.isLooping ? "STOP" : "START"}`);
        state.isLooping ? stopAudioPlayback() : playAudioBuffer();
    });

    async function fetchAndDecodeAudio(elementId) {
        console.log(`[fetchAndDecodeAudio] Fetching audio for element: ${elementId}`);
        const audioElement = document.getElementById(elementId);
        if (!audioElement) {
            console.error("Audio element not found:", elementId);
            return;
        }
        const audioSrc = audioElement.querySelector('source')?.src || audioElement.src;
        if (!audioSrc) {
            console.error("Audio source not found for element:", elementId);
            return;
        }

        try {
            const response = await fetch(audioSrc);
            const arrayBuffer = await response.arrayBuffer();
            audioContext.decodeAudioData(arrayBuffer, (buffer) => {
                state.audioBuffer = buffer;
                console.log("[fetchAndDecodeAudio] Audio data fetched and decoded successfully.");
            }, (error) => {
                console.error("Error decoding audio data:", error);
            });
        } catch (error) {
            console.error("Error fetching audio data:", error);
        }
    }

    function scheduleNextNote() {
        if (!state.isLooping || !state.audioBuffer) {
            console.log("[scheduleNextNote] Aborted: Either not looping or audioBuffer is null.");
            return;
        }

        let currentTime = audioContext.currentTime;
        console.log(`[scheduleNextNote] Current time: ${currentTime}`);

        // Adjusted to check if it's time to play or schedule the next note
        if (currentTime >= state.nextNoteTime) {
            playNote();
            // Immediately calculate and update nextNoteTime for the next note
            state.nextNoteTime += calculateBeatDuration(state.bpm) / state.scheduleMultiplier;
        }

        // Calculate the delay until the function should check again and ensure it's not zero
        let delayUntilNextCheck = Math.max((state.nextNoteTime - currentTime) * 1000, 10); // Use a minimum delay to avoid tight loops
        console.log(`[scheduleNextNote] Scheduling next check in: ${delayUntilNextCheck}ms`);
        setTimeout(scheduleNextNote, delayUntilNextCheck);
    }


    function playNote() {
        console.log("[playNote] Playing note.");
        const source = audioContext.createBufferSource();
        source.buffer = state.audioBuffer;
        const envelopeGainNode = audioContext.createGain();
        source.connect(envelopeGainNode).connect(gainNode);

        const currentTime = audioContext.currentTime;
        envelopeGainNode.gain.setValueAtTime(0.5, currentTime);
        console.log(`[playNote] Gain set to 0.5 at time: ${currentTime}`);

        source.start(currentTime);
        source.onended = () => {
            console.log("[playNote] Source ended. Cleaning up.");
            envelopeGainNode.disconnect();
            source.disconnect();
        };
        state.scheduledNotes.push(source);
    }

    function playAudioBuffer() {
        if (!state.isLooping) {
            console.log("[playAudioBuffer] Starting audio playback.");
            state.isLooping = true;
            state.startTime = audioContext.currentTime;
            // Directly schedule the first note to ensure it plays
            state.nextNoteTime = state.startTime;
            scheduleNextNote();
        }
    }



    function stopAudioPlayback() {
        if (state.isLooping) {
            state.isLooping = false;
            state.scheduledNotes.forEach(source => source.stop());
            state.scheduledNotes = [];
            // Optionally, reset nextNoteTime and startTime here if you want to ensure
            // they are recalibrated on next playback start.
            // However, this might not be necessary if playAudioBuffer always sets them correctly.
        }
    }



    // Util function to calculate beat duration
    function calculateBeatDuration(bpm) {
        return 60 / bpm;
    }

    // Updates the BPM and manages playback accordingly
    function updateBPM(newBPM) {
        console.log(`[updateBPM] Called with newBPM: ${newBPM}`);
        state.bpm = newBPM;
        if (state.isLooping) {
            stopAudioPlayback();
            playAudioBuffer();
        }
        displayUpdate('BPM', `${newBPM} BPM`);
    }

   // Function to display BPM or scheduling multiplier changes
    function displayUpdate(elementId, text, duration = 3000) {
        const element = document.getElementById(elementId);
        // Check if the update is for the multiplier
        if (text.startsWith("Multiplier:")) {
            const rawMultiplierText = text.split(": ")[1]; // Get the numeric part of the text
            let multiplier = parseFloat(rawMultiplierText);
            let displayText = " ";

            // Adjust the display text based on the multiplier value
            if (multiplier > 1) {
                // Multiplier is greater than 1, indicating a faster rate (doubling)
                let times = multiplier; // Use the multiplier directly since it's intended to show doubling
                displayText += `x${times}`;
            } else if (multiplier < 1 && multiplier > 0) {
                // Multiplier is less than 1, indicating a slower rate (halving)
                let fraction = 1 / multiplier; // Convert to fraction for display
                displayText += `1/${fraction}`;
            } else {
                // Multiplier is exactly 1, indicating the normal rate
                displayText += `1:1`;
            }

            element.textContent = displayText;
        } else {
            // For BPM updates or other text, display as is
            element.textContent = text;
        }

        // Temporarily show the updated text with some visual feedback
        element.classList.add('show');
        setTimeout(() => element.classList.remove('show'), duration);
    }


  // Listener for handling BPM changes
    document.addEventListener('bpmChange', (event) => {
        const adjustment = event.detail.adjustment;
        updateBPM(state.bpm + adjustment);
    });

    document.addEventListener('multiplierChange', (event) => {
    // Check if the event is to reset the multiplier
    if (event.detail.multiplier === 1) {
        // Directly reset the scheduleMultiplier to 1
        state.scheduleMultiplier = 1;
    } else {
        // Otherwise, apply the multiplier as before
        state.scheduleMultiplier *= event.detail.multiplier;
    }
    // Update the display to reflect the current multiplier
    displayUpdate('BPM', `Multiplier: ${state.scheduleMultiplier.toFixed(2)}`); // Using toFixed(2) for cleaner display
});


</script>
<script src="OB2_ActiveTab_Hotkeys_2.js"></script>
</body>
</html>
