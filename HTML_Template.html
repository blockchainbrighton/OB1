<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>OB1 #1 - Audional Art</title><style>body{background-color:#000000;display:flex;justify-content:center;align-items:center;height:100vh;margin:0}img {width: auto;height: auto;max-width: 60%;max-height: 80vh;object-fit: contain;aspect-ratio: 1 / 1;}
</style></head><body>
<img id="OB1_Image" src="data:image/jpeg;base64,/9j/4AAQSkZJRgABAQEAYABgAAD... shortened for brevity">
<audio id="audionalData" loop data-audionalSampleName="808 Kick Drum">
<source src="data:audio/wav;base64,UklGRk6GAQB... shortened for brevity">
Your browser does not support the audio element.
</audio>
<script>
    const audioContext = new (window.AudioContext || window.webkitAudioContext)();

    let bpm = 78;
    let beatDurationSeconds = 60 / bpm;

    let isLooping = false;
    let audioBuffer = null;
    let nextNoteTime = audioContext.currentTime;
    let attackFadeDuration = 0.01; // Initial attack fade duration in seconds, adjustable
    let tailFadeDuration = 0.001; // Initial tail fade duration in seconds, adjustable

    let scheduledNotes = []; // Array to keep track of scheduled notes


    const gainNode = audioContext.createGain();
    gainNode.connect(audioContext.destination);

    // Function to update BPM and recalculate beat duration
    // Modified updateBPM function to restart playback with new BPM
    function updateBPM(newBPM) {
        console.log(`[updateBPM] Called at ${new Date().toISOString()} with newBPM: ${newBPM}`);
        bpm = newBPM;
        beatDurationSeconds = 60 / bpm;
        console.log(`[updateBPM] BPM updated to ${bpm}, recalculated beatDurationSeconds to ${beatDurationSeconds}`);
        restartPlaybackIfNeeded();
    }


    // New function to restart playback if it's currently running
    function restartPlaybackIfNeeded() {
        if (isLooping) {
            stopAudioPlayback();
            playAudioBuffer();
        }
    }

    async function fetchAndDecodeAudio(elementId) {
        const audioElement = document.getElementById(elementId);
        const sourceElement = audioElement.querySelector('source');
        const audioSrc = sourceElement ? sourceElement.src : audioElement.src;

        try {
            const response = await fetch(audioSrc);
            const arrayBuffer = await response.arrayBuffer();
            audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
        } catch (error) {
            console.error("Error fetching or decoding audio data:", error);
        }
    }

    function scheduleNextNote() {
        console.log(`[scheduleNextNote] Called at ${new Date().toISOString()}`);
        if (!isLooping || !audioBuffer) {
            console.log("[scheduleNextNote] Exiting: isLooping or audioBuffer not ready.");
            return;
        }
        console.log(`Scheduling next note with BPM: ${bpm}, beatDurationSeconds: ${beatDurationSeconds}, nextNoteTime: ${nextNoteTime}`);

        // Clear any future notes that haven't started yet
        scheduledNotes.forEach(note => note.source.stop(audioContext.currentTime));
        scheduledNotes = [];

        const source = audioContext.createBufferSource();
        source.buffer = audioBuffer;
        source.connect(gainNode);

        scheduledNotes.push({source, startTime: nextNoteTime}); // Keep track of this note

        gainNode.gain.cancelScheduledValues(nextNoteTime);
        gainNode.gain.setValueAtTime(0.001, nextNoteTime);
        gainNode.gain.linearRampToValueAtTime(1, nextNoteTime + attackFadeDuration);

        source.start(nextNoteTime);

        if (audioBuffer.duration > beatDurationSeconds) {
            const crossFadeStartTime = nextNoteTime + beatDurationSeconds - tailFadeDuration;
            gainNode.gain.linearRampToValueAtTime(0.001, crossFadeStartTime);
        }

        nextNoteTime += beatDurationSeconds;

        const delayUntilNextNote = Math.max(nextNoteTime - audioContext.currentTime, 0) * 1000;
        setTimeout(scheduleNextNote, delayUntilNextNote);
        console.log(`[scheduleNextNote] Note scheduled at ${nextNoteTime}, with delayUntilNextNote: ${delayUntilNextNote}ms`);
    }

    // Adjustments to the playAudioBuffer and stopAudioPlayback functions as needed
    function playAudioBuffer() {
        console.log(`[playAudioBuffer] Called at ${new Date().toISOString()}`);
        if (!isLooping) {
            isLooping = true;
            nextNoteTime = audioContext.currentTime;
            console.log(`[playAudioBuffer] Starting playback. nextNoteTime set to ${nextNoteTime}`);
            scheduleNextNote();
        } else {
            console.log("[playAudioBuffer] Playback is already looping.");
        }
    }

    function stopAudioPlayback() {
        console.log(`[stopAudioPlayback] Called at ${new Date().toISOString()}`);
        if (isLooping) {
            isLooping = false;
            // Additional logic to stop currently playing BufferSource nodes
            console.log("[stopAudioPlayback] Stopping playback and clearing scheduled notes.");
            // Assuming scheduledNotes.forEach is called here
        } else {
            console.log("[stopAudioPlayback] Playback is already stopped.");
        }
    }

    document.getElementById("OB1_Image").addEventListener("click", async () => {
        console.log("Click detected...");
        if (!audioBuffer) {
            await fetchAndDecodeAudio("audionalData");
        }
        if (isLooping) {
            stopAudioPlayback();
        } else {
            playAudioBuffer();
        }
    });

    document.addEventListener('bpmChange', (event) => {
        const adjustment = event.detail.adjustment;
        // Assuming bpm is your global BPM variable
        bpm += adjustment;
        console.log(`BPM adjusted to ${bpm}. Recalculating beat duration...`);
        // Recalculate beatDurationSeconds and adjust scheduling as needed
    });

    document.addEventListener('multiplierChange', (event) => {
        const multiplier = event.detail.multiplier;
        // Assuming scheduleMultiplier is your global scheduling multiplier variable
        scheduleMultiplier *= multiplier;
        console.log(`Scheduling multiplier adjusted to ${scheduleMultiplier}. Adjusting playback scheduling...`);
        // Adjust playback scheduling as needed
    });

</script>
<script src="OB1_ActiveTab_Hotkeys.js"></script>
</body>
</html>
